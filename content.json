{"meta":{"title":"ThrowBadAlloc","subtitle":null,"description":"这个人很帅 没有留下足迹","author":"WangJing","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"","slug":"二叉树计本实现","date":"2017-06-15T08:21:58.573Z","updated":"2017-06-15T08:46:17.257Z","comments":true,"path":"2017/06/15/二叉树计本实现/","link":"","permalink":"http://yoursite.com/2017/06/15/二叉树计本实现/","excerpt":"","text":"二叉树的基本实现 在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2^{i-1}个结点；深度为k的二叉树至多有2^k-1个结点；对任何一棵二叉树T，如果其终端结点数为n_0，度为2的结点数为n_2，则n_0=n_2+1。 一棵深度为k，且有2^k-1个节点称之为满二叉树；深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树 #include&lt;iostream&gt; #include&lt;stack&gt; #include&lt;queue&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; typedef int Elemtype; #define END '#' template&lt;class Type&gt; const Type &amp;Max(const Type &amp;a,const Type &amp;b) { return a&gt;b?a:b; } //节点的结构体 typedef struct btNode { Elemtype data; btNode *leftchild; btNode *rightchild; }btNode,*BinTree; void PreNode(btNode *p)//先序遍历 { if(p!=NULL) { cout&lt;&lt;p-&gt;data&lt;&lt;\" \"; PreNode(p-&gt;leftchild); PreNode(p-&gt;rightchild); } } void InNode(btNode *p)//中序遍历 { if(p!=NULL) { InNode(p-&gt;leftchild); cout&lt;&lt;p-&gt;data&lt;&lt;\" \"; InNode(p-&gt;rightchild); } } void PastNode(btNode *p)//后序遍历 { if(p!=NULL) { PastNode(p-&gt;leftchild); PastNode(p-&gt;rightchild); cout&lt;&lt;p-&gt;data&lt;&lt;\" \"; } } void _FreeNode(btNode *p)//释放节点 { free(p); } btNode *CreateTree1()//输入创建树1 { btNode *s=NULL; Elemtype x; cin&gt;&gt;x; if(x!=END) { s=(btNode*)malloc(sizeof(btNode)); if(NULL==s) { cout&lt;&lt;\"内存开辟失败！\"&lt;&lt;endl; exit(1); } memset(s,0,sizeof(btNode)); s-&gt;data=x; s-&gt;leftchild=CreateTree1(); s-&gt;rightchild=CreateTree1(); } return s; } btNode *CreateTree2(Elemtype *&amp;str)//数组创建树2 { btNode *s=NULL; if(str!=NULL&amp;&amp;*str!=END) { s=(btNode*)malloc(sizeof(btNode)); if(NULL==s) { cout&lt;&lt;\"内存开辟失败！\"&lt;&lt;endl; exit(1); } s-&gt;data=*str; s-&gt;leftchild=CreateTree2(++str); s-&gt;rightchild=CreateTree2(++str); } return s; } btNode *CreateTree3(Elemtype **const pstr) { btNode *s=NULL; if(pstr!=NULL&amp;&amp;*pstr!=NULL&amp;&amp;**pstr!=END) { s=(btNode*)malloc(sizeof(btNode)); if(NULL==s) { cout&lt;&lt;\"内存开辟失败！\"&lt;&lt;endl; exit(1); } s-&gt;data=**pstr; s-&gt;leftchild=CreateTree3(&amp;++*pstr); s-&gt;rightchild=CreateTree3(&amp;++*pstr); } return s; } int Size(btNode *p) { if(p==NULL) { return 0; } else { return Size(p-&gt;leftchild)+Size(p-&gt;rightchild)+1; } } int Depth(btNode *p)//树的深度 { if(p==NULL) { return 0; } else { return Max(Depth(p-&gt;leftchild),Depth(p-&gt;rightchild))+1; } } void NicePreOrder(btNode *ptr)//非递归实现先序遍历 { if(ptr==NULL) { return ; } stack&lt;btNode *&gt; st; while(!st.empty()) { ptr=st.top(); st.pop(); cout&lt;&lt;ptr-&gt;data&lt;&lt;\" \"; if(ptr-&gt;rightchild!=NULL) { st.push(ptr-&gt;rightchild); } if(ptr-&gt;leftchild!=NULL) { st.push(ptr-&gt;leftchild); } } cout&lt;&lt;endl; } void NiceInOrder(btNode *ptr)//非递归实现中序遍历 { if(ptr==NULL) { return ; } stack&lt;btNode *&gt; st; while(ptr!=NULL||!st.empty()) { while(ptr!=NULL) { st.push(ptr); ptr=ptr-&gt;leftchild; } ptr=st.top(); st.pop(); cout&lt;&lt;ptr-&gt;data&lt;&lt;\" \"; ptr=ptr-&gt;rightchild; } cout&lt;&lt;endl; } void NicePastOrder(btNode *ptr) { if(ptr==NULL) { return ; } btNode *tag=NULL; stack&lt;btNode *&gt;st; while(ptr!=NULL||!st.empty()) { st.push(ptr); ptr=ptr-&gt;leftchild; } ptr=st.top(); st.pop(); if(ptr-&gt;rightchild==NULL||ptr-&gt;rightchild==tag) { cout&lt;&lt;ptr-&gt;data&lt;&lt;\" \"; tag=ptr; ptr=NULL; } else { st.push(ptr); ptr=ptr-&gt;rightchild; } cout&lt;&lt;endl; } void Destroy(btNode *pa)//释放树节点 { if(pa==NULL) { return ; } Destroy(pa-&gt;leftchild); Destroy(pa-&gt;rightchild); free(pa); } bool Equal(btNode *pa,btNode *pb)//树是否相等 { return (pa==NULL&amp;&amp;pb==NULL)||(pa!=NULL&amp;&amp;pa-&gt;data!=NULL&amp;&amp;pb!=NULL&amp;&amp;Equal(pa-&gt;leftchild,pb-&gt;leftchild)&amp;&amp;Equal(pa-&gt;rightchild,pb-&gt;rightchild)); } int main() { btNode *s=CreateTree1(); PreNode(s); return 0; }","categories":[],"tags":[]},{"title":"Sort","slug":"Sort","date":"2017-06-02T15:30:16.000Z","updated":"2017-06-02T15:35:12.126Z","comments":true,"path":"2017/06/02/Sort/","link":"","permalink":"http://yoursite.com/2017/06/02/Sort/","excerpt":"","text":"Sort arr是数组的地址，len为数组的长度。 1. 冒泡排序123456789101112131415161718192021222324252627void BubbleSort(int *arr,int len)&#123; if(arr==NULL||len&lt;=0) &#123; return ; &#125; int i,j; int tmp; for(i=0;i&lt;len-1;++i) &#123; int flag=0; for(j=0;j&lt;len-1-i;++j) &#123; if(arr[j]&gt;arr[j+1]) &#123; tmp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=tmp; &#125; flag=1; &#125; if(flag==0) &#123; return ; &#125; &#125;&#125; 冒泡排序的时间复杂度o(n^2),是稳定的，没有数据的跳跃式交换。 2. 插入排序123456789101112131415161718192021void InsertSort(int *arr,int len)&#123; if(arr==NULL||len&lt;=0) &#123; return ; &#125; int i,j; for(i=1;i&lt;len;++i) &#123; for(j=i;j&gt;0;--j) &#123; int data; if(arr[j-1]&gt;arr[j]) &#123; data=arr[j-1]; arr[j-1]=arr[j]; arr[j]=data; &#125; &#125; &#125;&#125; 插入排序的时间复杂度o(n^2),插入排序算法是稳定的，越有序越快。 3. 希尔排序123456789101112131415161718192021222324252627282930void Shell(int *arr,int len ,int size)&#123; int i,j; int tmp; for(i=size;i&lt;len;++i) &#123; for(j=i;j&gt;0;--j) &#123; if(arr[j-1]&gt;arr[j]) &#123; tmp=arr[j]; arr[j]=arr[j-1]; arr[j-1]=tmp; &#125; &#125; &#125;&#125;void ShellSort(int *arr,int len)&#123; if(arr==NULL||len&lt;=0) &#123; return ; &#125; int n=len/2; while(n&gt;=1) &#123; Shell(arr,len,n); n/=2; &#125;&#125; 希尔排序是插入排序的一种，也称缩小增量排序，希尔增量时间复杂度为O(n²) ，而Hibbard增量的希尔排序的时间复杂度为O(n^(3/2)),希尔算法是不稳定的。 4. 快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int Partition(int *arr,int low,int high)&#123; int tmp=arr[low]; while(low&lt;high) &#123; while((low&lt;high)&amp;&amp;(arr[high]&gt;=tmp)) &#123; high--; &#125; if(low==high) &#123; break; &#125; else &#123; arr[low]=arr[high]; &#125; while((low&lt;high)&amp;&amp;(arr[low]&lt;=tmp)) &#123; low++; &#125; if(low==high) &#123; break; &#125; else &#123; arr[high]=arr[low]; &#125; &#125; arr[low]=tmp; return low;&#125;static void Quick(int *arr,int start,int end)&#123; int par=Partition(arr,start,end); if(par&gt;start+1) &#123; Quick(arr,start,par-1); &#125; if(par&lt;end-1) &#123; Quick(arr,par+1,end); &#125;&#125;void QuickSort(int *arr,int len)&#123; if(arr==NULL||len&lt;=0) &#123; return ; &#125; Quick(arr,0,len-1);&#125; 快速排序是对冒泡排序的一种改进，快速排序的时间复杂度为o(N*logN)，快速排序的思想—分治法。不稳定。 5. 选择排序12345678910111213141516171819202122232425void SelectSort(int *arr,int len)&#123; if(arr==NULL||len&lt;=0) &#123; return ; &#125; int i,j; for(i=0;i&lt;len;++i) &#123; int key=arr[i]; int index=i; for(j=i;j&lt;len;++j) &#123; if(key&lt;arr[j]) &#123; int tmp=arr[j]; arr[j]=key; key=tmp; &#125; &#125; arr[index]=key; &#125;&#125; 选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。时间复杂度为0(n^2)。 6. 堆排序1234567891011121314151617181920212223242526272829303132333435363738394041void Adjust(int *arr,int start,int end)&#123; int tmp=arr[start]; for(int i=2*start+1;i&lt;=end;i=2*i+1) &#123; if((i+1&lt;=end)&amp;&amp;(arr[i]&lt;arr[i+1]))//左孩子小于右孩子 &#123; i++; &#125; if(arr[i]&gt;tmp) &#123; arr[start]=arr[i]; start=i; &#125; else &#123; break; &#125; arr[start]=tmp; &#125;&#125;void HeapSort(int *arr,int len)&#123; if(arr==NULL||len&lt;=0) &#123; return ; &#125; int tmp; int i; for(i=(len-1-1)/2;i&gt;=0;--i) &#123; Adjust(arr,i,len-1); &#125; for(i=0;i&lt;len-1;++i) &#123; tmp=arr[0]; arr[0]=arr[len-1-i]; arr[len-1-i]=tmp; Adjust(arr,0,len-1-i-1); &#125;&#125; 堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。此处代码时大根堆，堆排序的时间复杂度为0(N*logN),不稳定。 7. 归并排序123456789101112131415161718192021222324252627282930313233343536373839void Sort(int *ar,int *br,int low1,int high1,int low2,int high2)&#123; int k = low1; int i = k; while(low1 &lt;= high1 &amp;&amp; low2 &lt;= high2) &#123; if(ar[low1] &lt;= ar[low2]) br[k++] = ar[low1++]; else br[k++] = ar[low2++]; &#125; while(low1 &lt;= high1) br[k++] = ar[low1++]; while(low2 &lt;= high2) br[k++] = ar[low2++]; k--; for(int j = k; j &gt;= i; --j) &#123; ar[j] = br[j]; &#125;&#125;void Merge_sort(int *ar,int *br,int left,int right)&#123; int mid = left+(right-left)/2; if(left &lt; right) &#123; Merge_sort(ar,br,left,mid); Merge_sort(ar,br,mid+1,right); Sort(ar,br,left,mid,mid+1,right); &#125;&#125;void Merge_sort(int *ar,int len)&#123; int *br = (int *)malloc(sizeof(int)*(len)); assert(br != NULL); Merge_sort(ar,br,0,len-1); free(br);&#125; 归并排序（Merge-Sort）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。时间复杂度为O(Nlog N),空间复杂度o(n),归并排序是稳定的。 8. 桶排序 桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。1博主不会桶排序， 请写出你的伪代码！","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"c和c++的区别& gcc和g++的区别","slug":"c和c-的区别","date":"2017-05-25T18:40:16.000Z","updated":"2017-05-26T10:52:52.798Z","comments":true,"path":"2017/05/26/c和c-的区别/","link":"","permalink":"http://yoursite.com/2017/05/26/c和c-的区别/","excerpt":"","text":"一、c和c++的区别1. c语言是面向过程的，而c++是面向对象的。2. 带有默认值的函数（比较的是C89和c++99）C89没有带有默认值的函数（c99有）C++99有带有默认值的函数（从右向左给默认值）函数声明处也可以给默认值。 3. Inline函数C语言没有内联函数。内联函数：在函数的调用点，把函数的代码全部展开，编译过程所做的工作。而宏是在预编译展开的（预编译阶段不进行检查，纯粹的字符串替换），所以可以把内联函数称作更安全的宏（编译阶段进行类型检查）。Inline只在release版本起作用。Debug版本里面，illine函数的调用也需要栈帧的开辟和回退。 考察方向： 1. 内联函数与普通函数的区别? 内联函数没有标准的函数栈帧的开辟和回退。 普通函数有。2. 内联函数与static函数的区别是什么？ static函数产生符号（产生的符号是local，只本.cpp可见），内联函数不会产生符号。 4. 函数的重载C语言没有函数的重载。C++有函数的重载。（在c语言中，函数产生符号是由函数名称决定的，而在c++中，函数产生符号是由函数名称+形参的类型+形参的个数。所以可以构成函数的重载。）C++代码如何调用c代码？用extern “C”{} 在函数声明的时候加上。C如何调用c++不可见源代码？ 用extern “C”{} 把封装的接口变成c语言的接口 5. ConstC语言的const不是必须初始化的（c语言中，用const修饰的量叫常变量，不是常量） const修饰的常变量和普通的变量唯一的区别就是，常变量定义以后，不能作为左值。C++的const修饰的量必须初始化，（常量）Const的编译规则：c++中,所有使用常量名字的地方全部替换成常量的初始值 6. 引用C语言中没有引用。C++中有引用。引用必须初始化、初始化的值必须要能取地址、引用不能改变，没有二级引用、访问引用变量，永远访问的是它所引用的内存。 7. 动态开辟内存C语言开辟内存和释放 malloc freeC++是 new delete 8. 作用域C语言的作用域 ：局部作用域、全局作用域。C++的作用域 ： 局部作用域、类作用域、名字空间作用域namespace-&gt;全局的名字空间作用域和局部的名字空间作用域。 (详情请看施老师c和c++区别录屏1、2、3) 二、gcc 和g++ 的区别？Gcc/g++在执行编译工作的时候，总共需要4步(1) 预处理,生成.i文件(2) 将预处理后的文件转换成汇编语言,生成文件.s(3) 由汇编变成目标代码(机器代码)生成.o的文件(4) 连接目标代码,生成可执行程序。 后缀为.c的，gcc把它当作是c程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序，注意，虽然c++是c的超集，但是两者对语法的要求是由区别的,例如如下代码：12345678910111213#include&lt;stdio.h&gt;int main()&#123; int a=10; int b=20; int res=sum(a,b); printf(\"%d\\n\",res); return 0;&#125;int sum(int a,int b)&#123; return a+b;&#125; 如果按照c的语法规则编译，没问题。如果按照c++的语法规则编译，就会出现错误。 编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和c++使用的库连接，所以通常用g++来完成链接，为了统一起见，编译/链接统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的。 gcc不会定义_cplusplus宏，而g++会？ 实际上，这个宏只是标志这编译器将会把代码按c还是c++语言来解释，如果后缀为.c，并且采用gcc编译器，则该宏是未定义的，否则，就是已定义。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]}]}